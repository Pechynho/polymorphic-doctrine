# Polymorphic Doctrine

A Symfony bundle that provides polymorphic relations for Doctrine ORM, allowing you to create flexible associations where a single property can reference different entity types.

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## Features

- **Two polymorphic modes**: Dynamic and Explicit
- **Type-safe polymorphic relations** with proper IDE support
- **Foreign key constraints** preservation (explicit mode)
- **Query builder integration** for searching polymorphic values
- **Automatic reference class generation** for explicit mode
- **Caching support** for improved performance

## Installation

Install the bundle via Composer:

```bash
composer require pechynho/polymorphic-doctrine
```

If you're not using Symfony Flex, add the bundle to your `config/bundles.php`:

```php
<?php

return [
    // ...
    Pechynho\PolymorphicDoctrine\PechynhoPolymorphicDoctrineBundle::class => ['all' => true],
];
```

## Configuration

The bundle can be configured in your `config/packages/pechynho_polymorphic_doctrine.yaml`:

```yaml
pechynho_polymorphic_doctrine:
    # Directory where reference classes are generated (explicit mode)
    references_directory: '%kernel.cache_dir%/pechynho/polymorphic-doctrine/references'

    # Namespace for generated reference classes
    references_namespace: 'Pechynho\PolymorphicDoctrine\AutogeneratedReference'

    # Entity discovery configuration
    discover:
        cache_directory: '%kernel.cache_dir%/pechynho/polymorphic-doctrine/discover'
        directories:
            - '%kernel.project_dir%/src'
```

## Polymorphic Modes

### Dynamic Mode

Uses two database columns: one for the entity type and another for the entity ID. This approach is more flexible but doesn't preserve foreign key constraints.

For a dynamic polymorphic property, two columns are created:
- `{property_name}_type` - Stores the entity type key
- `{property_name}_id` - Stores the entity ID

**Example table structure for Payment entity with `dynamicSubject` property:**

**Sample data:**
| id | dynamic_subject_type | dynamic_subject_id |
|----|---------------------|-------------------|
| 1  | eshop_item         | 123               |
| 2  | subscription       | 456               |
| 3  | NULL               | NULL              |

### Explicit Mode

Creates one column for the entity type and separate columns for each possible entity type's ID. This preserves foreign key constraints and provides better database integrity.

For an explicit polymorphic property, multiple columns are created:
- `{property_name}_type` - Stores the entity type key
- `{property_name}_{type_key}_id` - One column for each mapped entity type

**Example table structure for Payment entity with `explicitSubject` property:**

**Sample data:**
| id | explicit_subject_type | explicit_subject_eshop_item_id | explicit_subject_subscription_id |
|----|----------------------|-------------------------------|----------------------------------|
| 1  | eshop_item          | 123                           | NULL                             |
| 2  | subscription        | NULL                          | 456                              |
| 3  | NULL                | NULL                          | NULL                             |

Foreign key constraints are automatically created for explicit mode columns, ensuring referential integrity.

## Usage

### 1. Define Your Entities

First, create the entities that will be referenced polymorphically:

```php
<?php

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class EshopItem
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    // ... other properties and methods
}
```

```php
<?php

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class Subscription
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    // ... other properties and methods
}
```

### 2. Create Entity with Polymorphic Relations

```php
<?php

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
use Pechynho\PolymorphicDoctrine\Attributes\DynamicPolymorphicProperty;
use Pechynho\PolymorphicDoctrine\Attributes\EntityWithPolymorphicRelations;
use Pechynho\PolymorphicDoctrine\Attributes\ExplicitPolymorphicProperty;
use Pechynho\PolymorphicDoctrine\Contract\PolymorphicValueInterface;

#[ORM\Entity]
#[EntityWithPolymorphicRelations]
class Payment
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ExplicitPolymorphicProperty([
        'eshop_item' => EshopItem::class,
        'subscription' => Subscription::class,
    ])]
    public PolymorphicValueInterface $explicitSubject;

    #[DynamicPolymorphicProperty([
        'eshop_item' => EshopItem::class,
        'subscription' => Subscription::class,
    ])]
    public PolymorphicValueInterface $dynamicSubject;
}
```

### 3. Working with Polymorphic Values

```php
<?php

namespace App\Service;

use App\Entity\EshopItem;
use App\Entity\Payment;
use App\Entity\Subscription;
use Doctrine\ORM\EntityManagerInterface;
use Pechynho\PolymorphicDoctrine\Contract\PolymorphicSearchExprApplierFactoryInterface;
use Pechynho\PolymorphicDoctrine\Contract\PolymorphicValueFactoryInterface;

class PaymentService
{
    public function __construct(
        private readonly EntityManagerInterface $em,
        private readonly PolymorphicValueFactoryInterface $polymorphicValueFactory,
        private readonly PolymorphicSearchExprApplierFactoryInterface $searchExprApplierFactory,
    ) {}

    public function createPayment(): void
    {
        $eshopItem = new EshopItem();
        $this->em->persist($eshopItem);

        $subscription = new Subscription();
        $this->em->persist($subscription);
        $this->em->flush();

        // Initialize polymorphic properties
        $payment = new Payment();
        $payment->dynamicSubject = $this->polymorphicValueFactory->create(Payment::class, 'dynamicSubject', $eshopItem);
        $payment->explicitSubject = $this->polymorphicValueFactory->create(Payment::class, 'explicitSubject', $subscription);
        $this->em->persist($payment);
        $this->em->flush();

        // update polymorphic values is done via method
        $payment->dynamicSubject->update($subscription);
        $payment->explicitSubject->update($eshopItem);

        $this->em->persist($payment);
        $this->em->flush();
    }

    public function workWithPolymorphicValue(Payment $payment): void
    {
        // Check status
        if ($payment->dynamicSubject->isNull()) {
            return;
        }

        if ($payment->dynamicSubject->isResolvable() && $payment->dynamicSubject->isLoaded()) {
            $value = $payment->dynamicSubject->getValue();

            if ($value instanceof EshopItem) {
                // Handle eshop item
            } elseif ($value instanceof Subscription) {
                // Handle subscription
            }
        }

        // Set to null
        $payment->dynamicSubject->setNull();
        $this->em->persist($payment);
        $this->em->flush();
    }
}
```

## API Reference

### Attributes

#### `#[EntityWithPolymorphicRelations]`

Mark an entity class to indicate it contains polymorphic relations. This attribute is required for entity discovery.

#### `#[DynamicPolymorphicProperty(array $mapping)]`

Defines a dynamic polymorphic property that uses two database columns (type and ID).

**Parameters:**
- `$mapping` - Array mapping type keys to entity class names
- `$iddProperty` - Custom ID property name (optional)
- `$enableDiscriminatorIndex` - Enable index on discriminator column (optional)
- `$enablePairIndex` - Enable index on type+ID pair (optional)

**Example:**
```php
#[DynamicPolymorphicProperty([
    'product' => Product::class,
    'service' => Service::class,
])]
public PolymorphicValueInterface $subject;
```

#### `#[ExplicitPolymorphicProperty(array $mapping)]`

Defines an explicit polymorphic property that creates separate columns for each entity type, preserving foreign key constraints.

**Parameters:**
- `$mapping` - Array mapping type keys to entity class names or detailed configuration
- `$idProperty` - Default ID property name (optional)
- `$idPropertyType` - Default ID property type (optional)
- `$onDelete` - Foreign key ON DELETE action (optional)
- `$onUpdate` - Foreign key ON UPDATE action (optional)
- `$enableDiscriminatorIndex` - Enable index on discriminator column (optional)
- `$enablePairIndex` - Enable index on type+ID pair (optional)

**Example:**
```php
#[ExplicitPolymorphicProperty([
    'product' => Product::class,
    'service' => [
        'fqcn' => Service::class,
        'idProperty' => 'serviceId',
        'onDelete' => 'CASCADE',
    ],
])]
public PolymorphicValueInterface $subject;
```

### PolymorphicValueInterface

The main interface for working with polymorphic values.

#### Methods

- `isNull(): bool` - Check if the polymorphic value is null
- `isResolvable(): bool` - Check if the value can be resolved to an entity
- `isLoaded(): bool` - Check if the entity is already loaded
- `setNull(): void` - Set the polymorphic value to null
- `update(?object $value): void` - Update the polymorphic value with a new entity
- `getValue(): ?object` - Get the actual entity object

### Services

#### PolymorphicValueFactoryInterface

Factory for creating polymorphic value instances.

```php
public function create(string $fqcn, string $property, ?object $value = null): PolymorphicValueInterface
```

#### PolymorphicSearchExprApplierFactoryInterface

Factory for creating search expression appliers for querying polymorphic values.

```php
$applier = $this->searchExprApplierFactory->create(Entity::class, 'propertyName', 'alias');
$applier->eq($queryBuilder, $entity); // Add WHERE condition
```

## Console Commands

### `pechynho:polymorphic-doctrine:cache-clear`

Clears the cache for polymorphic relations.

```bash
php bin/console pechynho:polymorphic-doctrine:cache-clear
```

This command clears both the polymorphic locator cache and generated reference classes cache.

### `pechynho:polymorphic-doctrine:generate-reference-classes`

Generates reference classes for explicit polymorphic properties.

```bash
php bin/console pechynho:polymorphic-doctrine:generate-reference-classes
```

**Important:** This command must be run after each change to polymorphic property definitions when using explicit mode. The generated classes are required for proper foreign key constraint handling.

## Searching Polymorphic Values

The bundle provides powerful search capabilities for polymorphic values through two main interfaces: **builders** and **appliers**. Both support the same search operations but differ in how they're used.

### Search Operations

All search interfaces support these operations:

- **`eq(entity)`** - Find records where polymorphic value equals the given entity
- **`neq(entity)`** - Find records where polymorphic value does not equal the given entity
- **`isNull()`** - Find records where polymorphic value is null
- **`isNotNull()`** - Find records where polymorphic value is not null
- **`isInstanceOf(class...)`** - Find records where polymorphic value is instance of given class(es)
- **`isNotInstanceOf(class...)`** - Find records where polymorphic value is not instance of given class(es)
- **`in(entities...)`** - Find records where polymorphic value is one of the given entities
- **`notIn(entities...)`** - Find records where polymorphic value is not one of the given entities

### Search Expression Builders

**PolymorphicSearchExprBuilderInterface** returns expression objects and parameters that you can use to manually build complex queries.

#### Usage Example

```php
use Pechynho\PolymorphicDoctrine\Contract\PolymorphicSearchExprBuilderFactoryInterface;

class PaymentService
{
    public function __construct(
        private readonly EntityManagerInterface $em,
        private readonly PolymorphicSearchExprBuilderFactoryInterface $builderFactory,
    ) {}

    public function findComplexPayments(EshopItem $item, Subscription $subscription): array
    {
        $qb = $this->em->createQueryBuilder();
        $qb->select('p')->from(Payment::class, 'p');

        // Create builder for the polymorphic property
        $builder = $this->builderFactory->create(Payment::class, 'dynamicSubject', 'p');

        // Build complex conditions
        $eqResult = $builder->eq($item);
        $instanceOfResult = $builder->isInstanceOf(EshopItem::class, Subscription::class);
        $inResult = $builder->in($item, $subscription);

        // Combine expressions manually
        $qb->where($qb->expr()->orX(
            $eqResult->expr,
            $instanceOfResult->expr,
            $inResult->expr
        ));

        // Set parameters
        foreach ([$eqResult, $instanceOfResult, $inResult] as $result) {
            foreach ($result->params as $key => $value) {
                $qb->setParameter($key, $value);
            }
        }

        return $qb->getQuery()->getResult();
    }
}
```

### Search Expression Appliers

**PolymorphicSearchExprApplierInterface** directly modifies the QueryBuilder, making it easier to use for simple queries.

#### Usage Example

```php
use Pechynho\PolymorphicDoctrine\Contract\PolymorphicSearchExprApplierFactoryInterface;

class PaymentService
{
    public function __construct(
        private readonly EntityManagerInterface $em,
        private readonly PolymorphicSearchExprApplierFactoryInterface $applierFactory,
    ) {}

    public function findPaymentsByEntity(object $entity): array
    {
        $qb = $this->em->createQueryBuilder();
        $qb->select('p')->from(Payment::class, 'p');

        // Create applier and directly apply condition
        $applier = $this->applierFactory->create(Payment::class, 'dynamicSubject', 'p');
        $applier->eq($qb, $entity);

        return $qb->getQuery()->getResult();
    }

    public function findPaymentsByType(string $entityClass): array
    {
        $qb = $this->em->createQueryBuilder();
        $qb->select('p')->from(Payment::class, 'p');

        $applier = $this->applierFactory->create(Payment::class, 'explicitSubject', 'p');
        $applier->isInstanceOf($qb, $entityClass);

        return $qb->getQuery()->getResult();
    }

    public function findNullPayments(): array
    {
        $qb = $this->em->createQueryBuilder();
        $qb->select('p')->from(Payment::class, 'p');

        $applier = $this->applierFactory->create(Payment::class, 'dynamicSubject', 'p');
        $applier->isNull($qb);

        return $qb->getQuery()->getResult();
    }

    public function findPaymentsExcluding(object ...$entities): array
    {
        $qb = $this->em->createQueryBuilder();
        $qb->select('p')->from(Payment::class, 'p');

        $applier = $this->applierFactory->create(Payment::class, 'dynamicSubject', 'p');
        $applier->notIn($qb, ...$entities);

        return $qb->getQuery()->getResult();
    }
}
```

## Best Practices

1. **Use explicit mode** when you need foreign key constraints and database integrity
2. **Use dynamic mode** when you need maximum flexibility and don't require foreign key constraints
3. **Always run the generate-reference-classes command** after modifying explicit polymorphic properties
4. **Clear cache** after making configuration changes
5. **Use meaningful type keys** in your mapping arrays for better readability

## Troubleshooting

### Common Issues

**Reference classes not found (explicit mode)**
- Run `php bin/console pechynho:polymorphic-doctrine:generate-reference-classes`
- Clear cache with `php bin/console cache:clear`

**Polymorphic properties not working**
- Ensure the entity is marked with `#[EntityWithPolymorphicRelations]`
- Check that the bundle is properly registered
- Verify your entity discovery configuration

**Performance issues**
- Enable appropriate database indexes using the `enableDiscriminatorIndex` and `enablePairIndex` options
- Consider using explicit mode for better query performance with foreign key constraints

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This bundle is released under the MIT License. See the [LICENSE](LICENSE) file for details.

## Author

- **Jan Pech** - [pechynho@gmail.com](mailto:pechynho@gmail.com)
